---
title             : "A Reproducible Data Analysis Workflow with R Markdown, Git, Make, and Docker"
shorttitle        : "Reproducible Data Analysis Workflow"

author: 
  - name          : "Aaron Peikert"
    affiliation   : "1,2"
  - name          : "Andreas M. Brandmaier"
    affiliation   : "1,3"
    corresponding : yes    # Define only one corresponding author
    address       : "Max Planck Institute for Human Development, Lentzeallee 94, 14195 Berlin, Germany"
    email         : "brandmaier@mpib-berlin.mpg.de"

affiliation:
  - id            : "1"
    institution   : "Center for Lifespan Psychology, Max Planck Institute for Human Development, Berlin, Germany"
  - id            : "2"
    institution   : "Humboldt-Universität zu Berlin"
  - id            : "3"
    institution   : "Max Planck UCL Centre for Computational Psychiatry and Ageing Research, Berlin, Germany & London, U.K." 

authornote: |
   We are grateful to Julia Delius for her helpful assistance in language and style editing. We thank the reviewers and all contributors of our GitHub repository for helpful feedback on the paper. This paper is fully reproducible using the workflow described in this paper. All materials can be found on the accompanying GitHub repository: [https://github.com/aaronpeikert/reproducible-research/](https://github.com/aaronpeikert/reproducible-research/). This particular document was created from the commit with the hash `"`r system2("git", "rev-parse --short HEAD", stdout = TRUE)`"`. To provide feedback or any other type of comment or questions regarding our workflow, please add an issue to the GitHub repository of our paper at [https://github.com/aaronpeikert/reproducible-research/issues](https://github.com/aaronpeikert/reproducible-research/issues).

abstract: "`r tryCatch(trimws(readr::read_file('abstract.Rmd')))`"

keywords          : "reproducibility, R, version management, dynamic document generation, dependency management, containerization, open science"

wordcount         : "`r tryCatch(wordcountaddin::word_count(here::here('manuscript.Rmd')), error=function(err) 'NA')`"

bibliography      : ["reproducible-research.bib"]

floatsintext      : yes
figurelist        : no
tablelist         : no
footnotelist      : no
linenumbers       : no
mask              : no
draft             : no

documentclass     : "apa6"
classoption       : "man"
output            : papaja::apa6_pdf
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(linewidth = Inf) # see wrap_code.R

if(!require("pacman"))install.packages("pacman")
pacman::p_load("here", "tidyverse")

knitr::read_chunk(here("R", "random.R"))
knitr::read_chunk(here("R", "bootstrap.R"))

source(here("R", "wrap_code.R"))
```

# Introduction

In this tutorial, we describe a workflow to ensure long-term and cross-platform reproducibility of data analyses in R [@baseR]. Reproducibility is the ability to draw identical conclusion from the same statistical analysis and the same data. In practice, reproducibility means to us that statistical results as well as their generating computational workflows are reported fully, and transparently, and remain sustainably available, such that a given workflow can be re-run by a different person, later in time, and that the results will be identical to the ones intially reported [@turingway2020; @herouxCompatibleReproducibilityTaxonomy2018; @claerboutElectronicDocumentsGive1992]. The need to ensure reproducibility directly follows from commonly accepted rules of good scientific practice [such as the guidelines of the German Research Foundation, @dfg2019]. Ensuring reproducibility is a prerequisite for replicability (the ability to reach a similar conclusion from the same analysis and new data), and a means to increase trustworthiness of empirical results [@epskamp2019rep]. Transparency and accessibility are  central scientific values and open, reproducible projects will increase the efficiency and veracity of knowledge accumulation [@nosek2012scientific].

Here, we combine four software tools, whose interplay can guarantee full computational reproducibility of data analyses and their reporting. There are various ideas on how to enhance reproducibility [@piccoloToolsTechniquesComputational2016], four of which we believe to be particularly important: dynamic document generation: [@ruleTenSimpleRules2019], version control [@barbaHardRoadReproducibility2016], dependency management [@askrenUsingMakeReproducible2016], and containerization [@clyburne-sherinComputationalReproducibilityContainers2018]. We argue that only a workflow using all four concepts in unison can guarantee confidence in reproducing a scientific report [see @turingway2020 for similar arguments]. Various implementations of these concepts exist, but we consider the following four best suited for the R environment [@r2019]: for dynamic document generation, R Markdown [@rmarkdown2019], for version control, Git [@chaconProGit2014], for dependency management, Make [@feldmanMakeProgramMaintaining1979], and for containerization, Docker [@merkelDockerLightweightLinux2014]. Each of these software solutions serves a valuable meta-scientific goal (reproducibility) and increases the researches' productivity. They all are highly flexible and powerful, so that mastering them fully, requires a considerable amount of practice. However, for our purposes, it is sufficient to master a valuable minimal subset of functions to ensure reproducibility of scientific analyses.

<!--To maximize chances of long-term reproducibility, proper documentation of all steps taken and their context is crucial since it answers the question "What steps have to be taken to reproduce the results?". The most precise documentation is computer code, and the most productive computer code is code that runs automatically without human interaction. This principle is what guided our use of R Markdown, Git, Make, and Docker.-->

# The Reproducible Workflow in a Nutshell

```{r schematic, eval = TRUE, echo = FALSE, fig.cap="Schematic illustration of the interplay of the four components central to a reproducible workflow: version control (git), dependency management (Make), containerization (Docker), and dynamic document generation (R Markdown). "}
knitr::include_graphics("Images/nutshell.svg", auto_pdf = TRUE)
```

Figure @\ref{fig:schematic} gives an overview of how the four components of our workflow interface to ensure computational reproducibility. We begin with a minimal description of the roles of the four components. In the remainder of this tutorial, we will further detail each of the four components of our workflow. The first component is version control. Version control manages  changes to files (e.g., data and code) over time so that you can access specific versions later. Version control offers snapshots of your workflow at different time points identified by a unique identifier. The different frames in the z-axis of the image illustrate the different versions of the workflow. How different parts of a analysis and a report of it relate and in what order they need to be executed is monitored using dependency management. The arrows visualize dependencies, such as an analysis depending on the availability of a particular data file. Third, all computer code (such as a statistical analysis in R) is executed in a virtual environment that guarantuees exact reproduction of results independent of the host operating system, R version, and installed package versions. Finally, dynamic document generation (also known as the literate programming paradigm) interweaves human-readable code and automatically produced results (such as point estimates, p values, or confidence intervals) to eliminate inconsistency errors such as those arising from careless copy and paste actions. 


# Dynamic Document Generation

The translation of computational results into a human-readable summary, for example into a technical report, a presentation, or a journal manuscript, is time-consuming and error-prone. Typical errors result from copy\&paste mistakes, erroneous rounding, or missed updates of the manuscript when the computer code has changed. In order to not only create fully reproducible results but also fully reproducible reports, one needs to resort to the Literate Programming paradigm [@knuth1984literate], in which human-readable language and computer code are intermingled to create dynamic documents whose order follows the logic of thought rather then the order of the computer. R Markdown is a simple markup language to create dynamic documents with embedded chunks of R code that can be exported to standard formats such as documents (docx, rtf, epub), presentations (ppt, html) or websites (html) using the `knitr` package [@xie2015; @xie2019]. Several packages extend the functionality of knitr. Of particular note are the `papaja` package [@papaja2018], which offers additional functions to enable American Psychological Association (APA) style document formatting, including a journal-style final typeset format, and the `stargazer` package [@stargazer2018], which provides journal-ready tables and reports of statistical models.  Figure \@ref{fig:source-rmarkdown} illustrates R Markdown syntax using the `papaja` package and Figure \@ref{fig:rendered-result} shows the resulting rendered document.

```{r source-rmarkdown, eval = TRUE, echo = FALSE,  fig.cap="Exemplary source of an R Markdown showing a combination of executable R code and English manuscript text."}
knitr::include_graphics("Images/rmarkdown.png")
```

```{r rendered-result, eval = TRUE, echo = FALSE,  fig.cap="Rendered result of the source code shown in Figure \ref{fig:source-rmarkdown}."}
knitr::include_graphics("R/rmarkdown.pdf")
```


# Version Management

Fundamentally, reproducibility means that computational results remain identical if neither the script nor the data have changed. It is often not trivial to find out whether any element in a project has changed over time and if so, to "go back in time." The Git program enables you to do both. A good mental model for Git is that it takes a sequence of snapshots of all files it is supposed to track. In the language of Git, these snapshots are "commits." A commit represents a complete copy of the state of all tracked files. Each commit has a short, unique identifier (a hash code) and a human-readable description (commit message). Going back to one state is as easy as traversing the history of all commits and switching the repository to a given previous state; it is possible to visually track changes between different versions (similar to the track changes function offered in Microsoft Word). The collection of all snapshots is called a "repository," which ideally tracks your entire R project.

A typical Git workflow in the terminal looks like this:

```{bash, eval=FALSE}
# -- type this in a terminal --
git init # to initialize git in the current directory
git add ./data/iris.csv ./R/analysis.R # track specific files
git commit -m "add data & analysis" # take snapshot with comment
# once script or data were changed, take a new snapshot
git commit -a -m "complete data colections" # add (-a) and commit all changes
```

To keep track of all changes on your local computer, you only need to use `git add` and `git commit` or `git commit -a` to add and commit at the same time. These commands need to be executed in the terminal, which you can access from within RStudio (`Shift + Alt + R`).  RStudio also offers a graphical user interface for Git. For most basic operations, this interface is convenient and sufficient (see Figure \@ref{fig:gitpane}).

```{r gitpane, eval = TRUE, echo = FALSE, fig.cap="Git Pane providing easy access to basic functions in RStudio"}
knitr::include_graphics("Images/git-pane.png")
```

In a given Git project, you can inspect all changes (`git log`) and examine any previous state by stating the identifier of the commit to `git checkout`:

```{bash, eval = FALSE}
# -- type this in a terminal --
git log # inspect all changes
git checkout 77db06f78e # revert local directory to previous version with hash code '77db06f78e'
```

Git also makes it particularly easy to share and collaborate on a project with other researchers. A popular service for sharing materials via Git is [GitHub](https://github.com). Alternatively, institutions can host an equally feature-rich open-source service called [GitLab](https://gitlab.com), avoiding the reliance on commercial service providers. Just sharing Git repositories on GitHub with the public is always free, private repositories (only visible to persons you invite) are [free for researchers](https://help.github.com/en/articles/applying-for-an-educator-or-researcher-discount) or have limited features. After creating a user account, one can create a new repository and GitHub provides information on how to upload your repository from the terminal, e.g., for our repository (here with user name 'aaronpeikert' and repository name 'reproducible-research'):

```{bash, eval=FALSE}
# -- type this in a terminal --

# link remote github repository to local directory
git remote add origin https://github.com/aaronpeikert/reproducible-research.git
# push all changes from local repository to the remote repository
git push -u origin master
```

`git push` or the green upward arrow in the Git pane (see Figure 3) uploads local updates. To download the remote Git repository on another computer, type into the terminal:

```{bash, eval=FALSE}
# -- type this in a terminal --
git clone https://github.com/aaronpeikert/reproducible-research.git
```

Git and GitHub can do even more to support you when collaborating with fellow researchers, for example, by providing a web interface to track issues and their status (open/closed/resolved) and further means to manage and merge multiple, parallel versions of code (such as branches, pull requests, or merges), but this is beyond the scope of this tutorial. In particular, GitHub's issue management can be leveraged as a post-publication platform to discuss manuscripts and their results [^1].
Another benefit of using Git and GitHub is that experimentation is highly encouraged since you can go back to any state quickly. Even when you lose access to the file on your computer, everything can be backed up on a remote Git server (like GitHub or GitLab). Further, one can reduce the liklihood of dead code accumulating (e.g., lines that have been commented out) because it is safe to simply remove unneeded code blocks and track their removal in Git.

GitHub allows you to archive and label a specific version of your repository in the form of a release. A release tags a particular commit with an arbitrary label, e.g., as "submission,"[^sub] "preprint," or "published," and archives also "binary" products of your code, e.g. the resulting pdf of the manuscript or the docker image (see [Containerization]). From such a release a DOI can be created, making it easier to reference it (see this [GitHub Guide](https://guides.github.com/activities/citable-code/)[^doi]).

[^1]: To comment on our paper, please add an issue to the GitHub repository of our paper: <https://github.com/aaronpeikert/reproducible-research/issues>.
[^doi]: [https://guides.github.com/activities/citable-code/](https://guides.github.com/activities/citable-code/)
[^sub]: We created an release for the submission: [https://github.com/aaronpeikert/reproducible-research/releases/tag/v0.1.1-submission](https://github.com/aaronpeikert/reproducible-research/releases/tag/v0.1.1-submission)

# Dependency Tracking and Management

Even when you have obtained a given version of a project with the aim to reproduce reported result and you can confirm that this version is unchanged, you may not know exactly how to reproduce the results because it may be unclear which files should be executed in which order. This is particularly the case when complex preprocessing pipelines are part of the computation and/or external dependencies (for example, a program needs to be called outside the R environment) are present. Handling such dependencies is easy with Make because it allows you to manage dependencies by creating (computational) recipes to create or recreate files.

A `Makefile` obeys a simple scheme. It contains a list of recipes. Each recipe has a target (the name of the recipe) followed by a list of dependent targets or files. If any of the dependencies have changed since the last time the target was built, the recipe's commands are executed to recreate the target file. We illustrate the use of Makefiles with an example. Assume the final product is a manuscript (`manuscript.pdf`). This manuscript is written in Rmarkdown (`manuscript.Rmd`) and includes dynamically generated plots from a raw data file (`data/iris.csv`) that needs to be preprocessed first using a separate script (`R/prepare_data.R`) into a prepared data file (`ìris_prepped.csv`). A `Makefile` for these dependencies may look like this:

```{bash, eval=FALSE}
# -- this is a Makefile --

manuscript.pdf: data/ìris_prepped manuscript.Rmd
  Rscript -e 'rmarkdown::render("manuscript.Rmd")'

data/ìris_prepped: R/prepare_data.R data/iris.csv
  Rscript -e 'source("R/prepare_data.R")'
```

The first line can be interpreted as follows: To create `manuscript.pdf` (the first target in the file), the file `manuscript.Rmd`, which depends on `data/ìris_prepped`, needs to be rendered. This dependency is itself a target (the second target in the file). To create `data/ìris_prepped`, `R/prepare_data.R` and `data/iris.csv` are needed. If you type `make manuscript.pdf`, Make first checks whether the dependencies do exist and, if not, creates them. Here, if `data/ìris_prepped` does not exist, Make creates it by executing the second target. Also, if one of the dependencies of a target is newer then the target itself, then Make updates everything that directly or indirectly depends on the target. Here, if `data\iris.csv` is newer then `data\ìris_prepped`, Make will attempt to recreate `data\ìris_prepped` first and then `manuscript.pdf`. If there is a dependency missing, and there is no target to make it, Make stops with an error message. It is a convention to have the first target named `all`, which depends on everything. Then the command `make` without any argument automatically creates everything possible in the project. The button `Build All` from within RStudio triggers this process (see Figure \@ref{fig:buildpane-rstudio}).

```{r buildpane-rstudio, fig.cap="Build pane in RStudio with access to Makefile target 'all'."}
knitr::include_graphics("Images/build-pane.png")
```


If you have followed our workflow as presented thus far, a fellow researcher is only three commands away from fully reproducing your analysis. They would simply have to type the following commands in the terminal:

```{bash, eval=FALSE}
# -- type this in a terminal --

# obtain a local copy from the remote repository
git clone https://github.com/aaronpeikert/reproducible-research.git
# enter the local copy
cd iris
# create all files from that project
make all
```

If you execute the above on your system, there is a good chance that you cannot reproduce our manuscript and the `make all` command exits with an error. Successful reproducibility relies on the crucial assumption that your computational environments are identically or sufficiently compatible, e.g., all software dependencies are installed (R and all additional R Packages) and no updates or other changes to the computational environment break or alter your analysis. As we will shortly see, ensuring full computational reproducibility requires one further level of documentation, that is, documentation of the computational environment.

# Containerization

Docker is a tool that allows encapsulation, sharing, and re-creation of a computational environment on most operating systems (Windows, macOS & Linux). Docker achieves these goals by setting up a virtual computer, on which it can execute well-defined series of commands (e.g., installing software). It then saves the resulting state of the virtual computer in what is called an "image." This image can be started and execute commands on the virtual computer, e.g., running `Rscript` or `make`. A running instance of an image is called a container. An image can be transferred and executed on any machine that has Docker installed. Irrespective of the machine that is executing the container, the computational environment is the same for the programs running inside the container. The most important advantage over traditional virtual machines is that containers are lightweight, that is, they start rapidly and do not need much storage space. Docker achieves this by reusing large parts of the host's operating system (the extend varies between Linux, macOS and Windows).

With the following example, we demonstrate why it is important to store the computational environment. Generally, with containers we would like to safeguard against changes to the computational environment with unexpected consequences, e.g., changes in the functionality or default options in packages or even in the R environment itself. While the R programming language is considered stable and much effort is put into backward compatibility, even basic functions like `sample()` (to randomly sample from a set) sometimes change their behavior from one version to another. To ensure reproducibility in analyses based on a computer's pseudo random number generator (PRNG), it is good practice to rely on fixed PRNG seeds, which are numeric values that set the PRNG into a deterministic state, i.e., the sequence of random numbers reproduces exactly. Consider the following R code to randomly draw five numbers between 1 and 10:

```{r,eval=FALSE}
# -- R code --
set.seed(1234)
sample(1:10, 5)
```

The usual expectation is that this code delivers the same pseudo-random five numbers regardless of the operating system or R Version (due to `set.seed()`). Using Docker, we can start an image which contains the R Version 3.5.0, and execute the code there.

```{r random, eval=FALSE}
```

This outputs:

```{r, child="R/random35.md"}
```

Executing the code in an image with a more recent version of R (3.6.1), this results in another sample despite the identical random seed:

```{r random, eval=FALSE}
```

This outputs:

```{r, child="R/random36.md"}
```

Note that this is intended behavior as it is the result of a [bugfix](https://bugs.r-project.org/bugzilla/show_bug.cgi?id=17494) in the random number generator implemented from R 3.6.0 upwards. Now, such changes may strictly render analyses run on previous R versions not reproducible if they contain, e.g., multiple imputations, bootstrapping, simulations studies, graphics with random jitter, Bayesian estimations using sampling algorithms (such as Markov Chain Monte Carlo), or similar techniques that involve random sampling. We would like to illustrate this with a more concrete example (the full R code to reproduce this non-reproducibility is provided in the GitHub repository of this manuscript). We ran a linear regression model on a simulated dataset with two variables `x` and `y` with R's `lm()` function regressing `x` on `y`. Using the `boot` package [@boot], we bootstrapped the 95% confidence intervals around the regression coefficient estimate with 1000 bootstrap samples to evaluate whether zero was inside the confidence interval. To make the analysis reproducible, we set a random seed. We ran this once in R 3.5.0:

```{r bootstrap, echo=TRUE, eval=FALSE}
```

```{r, child="R/bootstrap35.md"}
```

Then, we ran the identical script with the identical seed in R 3.6.1:

```{r bootstrap, echo=TRUE, eval=FALSE}
```

```{r, child="R/bootstrap36.md"}
```

As we see from these R outputs, the confidence intervals once include zero and once do not. Please note that one could discuss deeper issues about null hypothesis significance testing here but with this example, we would simply like to stress the point that computational reproducibility in the strict sense requires capturing the full computational environment. 

Only rarely does an analysis depend on base R only. Typically, a considerable number of packages is required that each may depend on multiple other packages, and the addition of each package will increase the likelihood of breaking reproducibility with every update to any of the packages of base R (the resulting frustration is sometimes refered to as _dependency hell_). The whole endeavor of reproducibility is therefore at stake every time an update is rolled out. To ensure long-term reproducibility, Docker replicates the original computational environment of an analysis exactly. Note that we do not intend to advocate that software should not be updated; updates typically promote bugfixes and provide new functionality; our point is that full computational reproducibility is only achieved if the software versions used originally are precisely documented. Among other things, this makes it possible to trace back update histories to discover which change in which package caused the non-reproducibility. Quite to the contrary, with containerization, it gets easier than ever to safely update to new versions just by changing the R version number of the Docker image (and reverting back if this update breaks code). This convenience is possible because of the efforts of the [Rocker project](https://GitHub.com/rocker-org/rocker) [@boettigerIntroductionRockerDocker2017a], which provides Docker images pre-configured with an installation of selected R versions. These packages are taken from MRAN [@revolutionanalyticsReproducibilityUsingFixed2019], a repository for R packages fixed to the last date on which the R version of the image was the most recent. Building upon these Rocker images, researchers can easily build their own Docker images with all required R packages. The rocker project also provides images that include RStudio (`rocker/rstudio`), the `tidyverse` package (`rocker/tidyverse`) and the R Markdown package with LaTeX (`rocker/verse`). Because our workflow relies on R Markdown, we suggest using the `rocker/verse` image (which also contains `rstudio` & `tidyverse`). These images are stored on [Dockerhub](https://hub.docker.com) [@dockerinc.DockerHub2019].

Building on a basic Rocker image, we can specify further software dependencies in a Dockerfile. For example, the basis for this manuscript's Docker image is the following Dockerfile:

```{bash, eval=FALSE}
# -- this is a Dockerfile --

# Define the R version to be installed from rocker project
FROM rocker/verse:3.6.1
# install CRAN R packages: pacman, here, and pander
RUN install2.r --error --skipinstalled\
  pacman here pander
# install additional R packages from github: papaja and wordcountaddin
RUN installGithub.r\
  crsh/papaja benmarwick/wordcountaddin
# set the working directory inside the container
WORKDIR /home/rstudio
```

The `FROM` statement specifies which Docker image to use, in this case, the `rocker/verse` image with the tag 3.6.1 (referring to the R version 3.6.1). The `RUN` statement describes a command to execute, in this case, to run an R script `install2.r` which is available on all Rocker images, to install the specified packages (here, `pacman`,  `here` & `pander`). A Dockerfile allows more than one `RUN` statement, executing arbitrary system commands. Those `RUN` statements can install dependencies that are not an R package, e.g., other programming languages like python or Matlab. The `WORKDIR` statement is not strictly necessary but saves time spent on writing the working directory. The command `docker build -t image-name` creates an image named `image-name` from the Dockerfile in the project. A way to identify the dependencies automatically and generate a docker image out of them is provided in the [`liftR`](https://cran.r-project.org/web/packages/liftr/vignettes/liftr-intro.html) package [@liftr].

The flexibility to fully control the software environment is of particular interest for software infrastructures where users cannot install software because of limited access rights, for example, on cloud computing platforms or high-performance computing clusters. However, docker needs unrestricted access rights to the system, which are rarely granted on high-performance computing clusters. For this case, Singularity provides a fully compatible alternative (see Section under [Linux]) that can be executed with limited access rights.

There are two ways to share a Docker image; either by sharing the Dockerfile that creates the image, or by sharing the image itself, e.g., through a service like [Dockerhub](https://hub.docker.com). While both ways guarantee a replicable computational environment, sharing the Dockerfile is more transparent and more space-saving; in our workflow, we can use Git to track changes in the Dockerfile (such as updates to dependencies). A possible downside is that in order to create an image from a Dockerfile, all software repositories need to be still available. Hence, to guarantee longterm reproducibility, it is best to archive the complete binary image at major points of the projects' progress, for example, on publication (ideally, using a release tag; see [Version Management] for details).

There are two options to execute commands in a container. Both options are based on the `docker run` command. The first way is to run a command inside the container. The call takes the form:

```{bash, eval=FALSE}
# -- type this in a terminal --

# execute a given command in a given container image; do not save
# the state of the container; accept inputs from and return outputs to terminal
docker run --rm -it <IMAGENAME> <COMMAND>
```

The `--rm` flag means that the state of the container after the command will have finished is not going to be saved. The `-it` flag tells Docker to run the command interactively, that is, to accept keyboard inputs and return outputs to the terminal. For example, this is the command to start an interactive R session inside a Docker image called `reproducible-research` (see Figure \@ref{fig:docker-r-terminal} for a screenshot):

```{bash, eval=FALSE}
# -- type this in a terminal --

# start an interactive R session in the container named 'reproducible-research'
docker run --rm -it reproducible-research R
```

```{r docker-r-terminal, eval = TRUE, echo = FALSE, fig.cap="R terminal running inside Docker"}
knitr::include_graphics("Images/docker-r-terminal.png")
```

The second option is to start the container in the background and to interact with the container via the webrowser and the RStudio server instance running in it. In order to do so, you need to supply a password to log into the RStudio server (`-e PASSWORD=<YOUR_PASS>`) and open a network service on a specified port (`-p 8787:8787`).

```{bash, eval=FALSE}
docker run -e PASSWORD=<YOUR_PASS> -p 8787:8787 image-name
```

The adress to connect to the RStudio server is your IP address (or `localhost` Linux) in this scheme: `<IPADRESS>:8787`. This offers a fully functioning RStudio instance that runs in the image but is accessible through a local web browser.

By default, programs inside the container cannot access files on the local computer, thus requiring an explicit link to a local folder to enable access (and on macOS and Windows this also have to be allowed in the settings) :

```{bash, eval=FALSE}
docker run -v /folder/on/your/computer:/folder/in/docker 
```

The main directory for RStudio inside the container is `/home/rstudio`, so the complete call to start RStudio inside a Docker container may look like this in the local terminal:

```{bash, eval=FALSE}
# start docker in the background, open a local web service with a virtual
# Rstudio instance and enable access to selected local directories
docker run --rm -it -e PASSWORD=<YOUR_PASS> -p 8787:8787 -v
/path/to/project:/home/rstudio reproducible-research
```

```{r rstudio-in-docker, eval = TRUE, echo = FALSE, fig.cap="RStudio running inside Docker"}
knitr::include_graphics("Images/docker-rstudio.png")
```

Figure \@ref{fig:rstudio-in-docker} shows a screenshot of Rstudio running inside Docker accessed from a local web browser.

Since Docker commands tend to grow long and become tedious to type manually, we recomend using some automatic way to generate them. Fortunately, one can use Make to automatically generate the `docker` commands, e.g. the (simplified) `Makefile` for this paper allows command after `$(run)` to be conditionally passed through Docker if one types `make DOCKER=TRUE` (otherwise, they are run locally):

```{bash, eval=FALSE}
# -- this is a Makefile --

project := $(notdir $(CURDIR))
current_dir := $(CURDIR)
home_dir := $(current_dir)
uid = --user $(shell id -u)

ifeq ($(DOCKER),TRUE)
	run:=docker run --rm --user $(uid) -v $(home_dir):/home/rstudio $(project)
	current_dir=/home/rstudio
endif

all: manuscript.pdf

build: Dockerfile
	docker build -t $(projekt) .

manuscript.pdf: manuscript.Rmd reproducible-research.bib
	$(run) Rscript -e 'rmarkdown::render("$(current_dir)/$<")'
```

# Installing and Setting Up the Workflow

Other than on R, RStudio, and R Markdown, our workflow relies on three pieces of software from outside the R environment: Git, Make, and Docker. The smoothness of the installation process of these software packages varies across operating systems. For example, on macOS, Make is always available, whereas Linux systems are typically shipped with both Git and Make. In the following section, we share what what we consider the easiest way to install those packages across common operating systems. However, installation processes may be subject to change, and we advise that readers also consult the documentations of the packages or see our collection of links to tutorials and installation instructions on our GitHub repository.

## Windows

Windows systems typically require the biggest efforts to install all necessary pieces of software. Note that you have to have either Windows Pro, Enterprise, Education, or Server installed, as Microsoft prevents the use of Docker on Windows Home. There is a package manager for Windows called Chocolatey, which you can install from: [https://chocolatey.org/install](https://chocolatey.org/install). Chocolatey provides all software packages needed for our workflow in one place..
Having installed Chocolatey (and restarted the computer), all dependencies can be installed in an **admin terminal** (Windows key, then type `cmd`, right-click *Run as administrator*) via:

```{bash, eval=FALSE}
# -- type this in a terminal --

# install docker, make, and git using choco
choco install -y git make docker-desktop
```

To use `docker` you need to start Docker Desktop. In the settings of Docker Desktop you have to allow the sharing of your drive. Docker on Windows require the path to be special; therefore you need to hand edit the `Makefile` and set `current_path` to the current directory and use `make all DOCKER=TRUE WINDOWS=TRUE`. We hope that future releases of Docker for Windows will not require that workaround.

## macOS

As Make already ships with macOS, you only need Git and Docker. We suggest using the package manager Homebrew, which you can install from [https://docs.brew.sh/Installation](https://docs.brew.sh/Installation), to install Docker (Git will be installed during the installation of Homebrew):

```{bash, eval=FALSE}
# -- type this in a terminal --

# install docker via brew
brew cask docker
```

To use `docker` you need to start Docker Desktop. In the settings of docker you have to allow the sharing of your drive.

## Linux

There is a host of different Linux distributions and almost as many package managers. Still, to our knowledge, there is no (recent) Linux edition, that does not include Git, Make and Docker. For example, in Ubuntu Linux, installation is straightforward using the shipped package manager:

```{bash, eval=FALSE}
# -- type this in a terminal --

# install docker via advanced package tool
apt install git make docker 
```

For other distributions, replace `apt` with the native package manager. You may need elevated rights for the installation; in this case add `sudo` before the installation command. `docker` also needs elevated rights to run; therefore, we recommend adding the local user to the `docker` group, following the [documentation of Docker](https://docs.docker.com/install/linux/linux-postinstall/#manage-docker-as-a-non-root-user).

An alternative to Docker on Linux is Singularity [@kurtzerSingularityScientificContainers2017]. To use it, just replace any docker calls with `singularity docker`, because singularity fully supports docker images. A possible advantage is that singularity works well in high-performance computing environments and on old Linux versions, the downside is that Singularity is currently only available on Linux.

# Project organization

Finally, we conclude with some notes on project organization, which we think makes migrating projects to a reproducible workflow easier. The first step towards reproducibility is to create an R script or R Markdown file as primary entry point for the analysis that runs on a local computer without error and performs the main statistical analyses. Next, one needs to make sure that all files relevant for the analysis can be moved to another computer. To this end, it is recommendable that all files are within one folder (or enclosed subfolders within it) and all paths are relative to that folder because absolute paths are specific to a given computer. A robust solution to the problem of making sure that file access does not break across computing platforms are [RStudio projects](https://r4ds.had.co.nz/workflow-projects.html) and the `here` package [@here2017] to manage file access. The here package solves two common issues with relative paths. First, it takes care of the fact that path separator characters vary across operating systems (typically, slash or backslash). Second, anchor points of relative paths may differ depending on context. For example, knitr interprets paths relative to the dynamic document whereas R has a current working directory that may change over the course of an R ssession. The `here` package provides consistent paths relative to the project directory. The following are three examples of refering to local files ranging from absolute paths with system-specific path separators (bad) to relative paths using the `here` package: 

```{r, eval=FALSE}
# -- R code --

# BAD because of path that is specific to the computer
iris <- read.csv("/home/aaron/reproducible-research/data/iris.csv")
# GOOD because it is a relative path but slash depends on OS
iris <- read.csv("data/iris.csv")
# BETTER because truly compatible across OS
iris <- read.csv(here("data", "iris.csv"))
```

The folder where all the files reside that you need for analysis (code and data), is referred to as a 'project' (or sometimes as a 'research compendium'). Working with projects is particularly convenient with RStudio, an integrated development environment (IDE) for R. It is useful to organize a data analysis project in a way that strictly segregates (raw) data and code by placing them in directories called `data` and `R` [see Section 4 in @marwickPackagingDataAnalytical2018]; there are also tools that automatize the standardized creation of folder structures such as `workflowr` [@workflowr].

Sometimes external requirements make it impossible for the data to be stored and shared together with the scripts. In most of the cases we have seen, these are either space constraints or privacy considerations. In these cases, unrestricted reproducibility is not guaranteed. If dividing data and scripts is unavoidable, we recommend validating all data files using checksums (also called a "hash", e.g., using the functions provided in package `digest` [@digest2019]) before analyzing them. A checksum is a short fixed-length fingerprint (often displayed in hexadecimal system) of a file with the purpose of verifying integrity of a digital object. Fingerprints are computed from digital objects such that they change with high probability if data is changed only little. To use checksum validation, checksums for all data files must be created and stored at the time of the original analysis. At the time of reproduction, the current checksum must then be compared with the stored checksum to ensure data integrity.

```{r}
# create a dummy data.frame with two columns
x <- data.frame(VAR1=c(1,2,3,4),VAR2=c(0,4,6,9) )
# compute checksum using md5
checksum <- digest::digest(x, "md5")
if (checksum != "5ba412f5a26f43842971dd74954fcdeb"){
  warning("Mismatch between original and current data file!")
}
```


## Use Case: Reproducing an Analysis

We provide a reproducible analysis as a working example via [GitHub](https://github.com/aaronpeikert/workflow-showcase). We encourage interested readers to try to reproduce this example as a practical exercise. The example shows a minimalistic analysis of the 'Considerations of Future Consequences (CFC) Scale'. The analysis demonstrates a complete implementation of our workflow including downloads of external data, comparison of their integrity using a checksum, and  a confirmatory factor analysis on the first few items using the R package `lavaan` [@lavaan2012]. Once all required tools are installed on a computer, the following four command-line commands are sufficient to reproduce our demo analysis:

```{bash, eval=FALSE}
# -- type this in a terminal --

# (1) obtain a local copy of the remote repository
git clone https://github.com/aaronpeikert/workflow-showcase.git
# (2) enter the directory containing the project
cd workflow-showcase
# (3) build the docker container
make build
# (4) run the analysis and produce the final PDF inside the container
make all DOCKER=TRUE
```

# Summary

The overarching goal of this paper was to provide a complete and easy-to-use workflow that allows confidence in reproducibility of R-based data analyses. Analyses following our workflow can be reproduced with four commands (here shown for our paper):

```{bash, eval=FALSE}
# -- type this in a terminal --

# (1) obtain a local copy of the remote repository
git clone https://github.com/aaronpeikert/reproducible-research.git
# (2) enter the directory containing the project
cd reproducible-research
# (3) build the docker container
make build
# (4) run the analysis and produce the final PDF inside the container
make all DOCKER=TRUE
```

That is, this reproduces a scientific report exactly without regard to the user, the operating system, the software, the timepoint, or interim changes to the involved files. To that end, the proposed workflow relies on tools that have been the foundation of reliable software development for years or, even decades. As a by-product, it makes transparent how statistical results depend on the software that created them and, by virtue of this transparency, facilitates later re-use by other researchers. 

Each tool in the workflow reduces the chances of non-reproducibility. Dynamic reporting with R Markdown guarantees consistency between computational results and their reporting; Version control with Git ensures permanence and consistency across multiple versions of data and code; Dependency management with Make affirms defined entry-points and dependency resolution; containerization with Docker secures reproducibility of the full computational environment. We believe that this tightening of loose ends does not restrict researchers but enables them to operate on a solid basis to deliver sound and sustainable research.

## Related approaches

While our approach was designed to scale well with the complexity of a computing-intense project, we realise that this flexibility may not be straightforward to integrate into a researcher's everyday workflow. There are R packages that implement parts of our workflow and, thus, lower the threshold for adoption when the full flexibility provided by our workflow is not needed. The use of R Markdown within a project, tracked with Git can be simplified with the [`workflowR`](https://github.com/jdblischak/workflowr) package [@workflowr]. The [`drake`](https://github.com/ropensci/drake) package [@drake] is directly inspired by Make and takes an R centric approach, making it especially suited for projects only involving R, but can also handle external dependencies. The [liftR ](https://cran.r-project.org/web/packages/liftr/vignettes/liftr-intro.html) package [@liftr] and the [`holepunch`](https://karthik.github.io/holepunch/) package [@holepunch] automatize the use of Docker. The former is perfectly compatible with the described workflow and we recommend it to users  who are not comfortable with command-line use of Docker. `holepunch` uses [binder](https://mybinder.org) [@binder2018] to move the analysis to the cloud, so that no local installation of Docker is required. `holepunch` is well suited for simple analysis with low computational demands, because binder's  memory and computing time is limited. There are several alternatives to Docker that manage dependencies on R packages. [`renv`](https://rstudio.github.io/renv/articles/renv.html) [@renv] is a way to freeze package version via local copies of packages in the project, but it does not gurantee a given base R version or system dependencies. Similar approaches are taken by [`jetpack`](https://github.com/ankane/jetpack) [@jetpack], [`miniCRAN`](https://cran.r-project.org/web/packages/miniCRAN/vignettes/miniCRAN-introduction.html) [@miniCRAN] and [`checkpoint`](https://cran.r-project.org/web/packages/checkpoint/vignettes/checkpoint.html) [@checkpoint]. The package [`reprex`](https://github.com/tidyverse/reprex) [**repr**oducible **ex**ample, @reprex] is also worth noting, but its scope is limited. A particularly noteworthy approach is provided by the [`worcs`](https://cran.r-project.org/web/packages/worcs) package [@worcs, @worcspaper], which is an R project template that creates a standardized file structure for code and data supporting version management with git, package management with renv and dynamic document generation with R Markdown. We acknowledge that worcs is much easier to install and provides a one-click solution for the creation of reproducible projects. It achieves a high standard of reproducibility but does not guarantuee full computational reproducibility and is limited to dependency management within the R environment.

Other than these tools, which ease the process of creating workflows like ours does, we have noticed increased interest in changing the way research is published and used [@perkelToolkitDataTransparency2018], with the emergence of *life code* [@perkelPioneeringLivecodeArticle2019] and *continuous integration* [@beaulieu-jonesReproducibilityComputationalWorkflows2017; @yenniDevelopingModernData2018]. These techniques give us a glimpse of a paradigm shift from static to dynamic, interactive, and living publications that is yet to happen.

## Limitations

We are aware that implementing the proposed workflow is not straightforward and the difficulty of its implementation may vary by platform. For example, the installation of all tools is already easier on POSIX-compatible platforms such as Unix, Linux, or macOS (but not Windows). However, once a reproducible workflow is established as a default, it can be used with minimal changes for every R project.

In our own experience, it is often not possible to convince all co-authors to switch to a different document processing environment, such as R Markdown. That is, we have experienced the case that after writing up the first draft in R Markdown, we eventually had to generate a Word file that, from then on, was used as static file serving as a basis for multiple iterations among the co-authors. Retaining reproduciblity in such situations then requires tedious manual synchronization of files across formats. This annoyance may be reduced with the [`redoc` package](https://noamross.github.io/redoc/articles/mixed-workflows-with-redoc.html) [@redoc], which enables a bidirectional synchronization between Word and R Markdown. Conversions between R Markdown and Word retain all changes and even support Word's track-changes feature.

## Sharing reproducible workflows

How can one best share a reproducible workflow? We believe that, ideally, a non-commercial public service provider should be found that guarantees permanent and reliable hosting of our reproducible workflows, such as the Open Science Framework [@fosterOpenScienceFramework2017]. A provider mirroring and complementing the services offered by GitHub, Docker Hub, and MRAN would be desirable. Second, to ensure that other users are legally able to benefit from the shared materials, authors must choose an appropriate license format. Typically, there is currently no single license that works for code, data, and media (such as text or figures). We encourage authors to choose appropriate license forms that do not hinder others from freely downloading, using, and modifying the shared workflows and materials while, at the same time, ensuring recognition for the time and effort invested into creating the workflow in the first place. In our experience, the Creative Commons license (CC-BY) is often appropriate for sharing texts, R Markdown files, generated figures, and other media, whereas scripts and any other computer code are often best shared according to the MIT license. Both licenses assure maximal freedom for future users while requiring the attribution of the original authors in derivative work. These licenses are also in line with the recommendations by the Reproducible Research Standard [@stoddenEnhancingReproducibilityComputational2016; @stoddenEnablingReproducibleResearch2009]. To facilitate an inclusive environment we recommend naming all contributors and including a [Code of Conduct](https://opensource.guide/code-of-conduct/) in your project.

## Outlook

The proposed workflow leverages various existing tools that are partly integrated into RStudio already. Parts of the proposed workflow have been integrated into stand-alone packages (such as worcs [@worcs], workflowr [@workflowr], holepunch  [@holepunch]), which are particularly recommenable to beginners but they are either incomplete in the sense of our proposal or rely on proprietary service providers. We hope that with increasing awareness of the challenges of computational reproducibility, the increased demand for unified and open solutions will lead to an even better integration of existing tools to allow reproducible workflows to become a standard in psychological research.

\newpage

# References

\begingroup
\setlength{\parindent}{-0.5in}
\setlength{\leftskip}{0.5in}

<div id="refs" custom-style="Bibliography"></div>
\endgroup
