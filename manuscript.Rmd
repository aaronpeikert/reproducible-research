---
title             : "A Reproducible Data Analysis Workflow with R Markdown, Git, Make, and Docker"
shorttitle        : "Reproducible Workflow"

author:
  - name          : "Aaron Peikert"
    affiliation   : "1,2"
  - name          : "Andreas M. Brandmaier"
    affiliation   : "1,3"
    corresponding : yes
    address       : "Max Planck Institute for Human Development, Lentzeallee 94, 14195 Berlin, Germany"
    email         : "brandmaier@mpib-berlin.mpg.de"

affiliation:
  - id            : "1"
    institution   : "Center for Lifespan Psychology, Max Planck Institute for Human Development, Berlin, Germany"
  - id            : "2"
    institution   : "Humboldt-Universit√§t zu Berlin"
  - id            : "3"
    institution   : "Max Planck UCL Centre for Computational Psychiatry and Ageing Research, Berlin, Germany & London, U.K."

authornote: |
   We are grateful to Julia Delius for her helpful assistance in language and style editing. We thank the reviewers and all contributors of our GitHub repository for helpful feedback on the paper. This paper is fully reproducible using the workflow described in this paper. All materials can be found on the accompanying GitHub repository: [https://github.com/aaronpeikert/reproducible-research/](https://github.com/aaronpeikert/reproducible-research/). This document is based on the commit identified by hash `"`r system2("git", "rev-parse --short HEAD", stdout = TRUE)`"`. To provide feedback or any other type of comment or questions regarding our workflow, please add an issue to the GitHub repository of our paper at [https://github.com/aaronpeikert/reproducible-research/issues](https://github.com/aaronpeikert/reproducible-research/issues).

abstract: "`r tryCatch(trimws(readr::read_file('abstract.Rmd')))`"

keywords          : "reproducibility, R, version management, dynamic document generation, dependency management, containerization, open science"

wordcount         : "`r tryCatch(wordcountaddin::word_count(here::here('manuscript.Rmd')), error=function(err) 'NA')`"

bibliography      : ["reproducible-research.bib"]

floatsintext      : yes
figurelist        : no
tablelist         : no
footnotelist      : no
linenumbers       : no
mask              : no
draft             : no

documentclass     : "apa6"
classoption       : "man"
output            : papaja::apa6_pdf
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(linewidth = Inf) # see wrap_code.R

if(!requireNamespace("pacman"))install.packages("pacman")
pacman::p_load("here", "tidyverse")

knitr::read_chunk(here("R", "random.R"))
knitr::read_chunk(here("R", "bootstrap.R"))

source(here("R", "wrap_code.R"))
```

# Introduction

In this tutorial, we describe a workflow to ensure long-term and cross-platform reproducibility of data analyses in R [@baseR]. Reproducibility is the ability to draw identical results from the same statistical analysis and the same data. For us,  statistical results are only reproducible if their generating, computational workflow is reported fully and transparently, and remains sustainably available, such that the workflow can be re-run by a different person or later in time, and that the results will be identical to the ones initially reported [@turingway2020; @herouxCompatibleReproducibilityTaxonomy2018; @claerboutElectronicDocumentsGive1992]. The need to ensure reproducibility directly follows from commonly accepted rules of good scientific practice [such as the guidelines of the German Research Foundation; @dfg2019]. Ensuring reproducibility is a prerequisite for replicability (the ability to reach a similar conclusion from the same analysis and _new_ data), and a means to increase the trustworthiness of empirical results [@epskamp2019rep]. Transparency and accessibility are central scientific values, and open, reproducible projects will increase the efficiency and veracity of knowledge accumulation [@nosek2012scientific].

Here, we combine four software tools, whose interplay can guarantee full computational reproducibility of data analyses and their reporting. There are various ideas on how to enhance reproducibility [@piccoloToolsTechniquesComputational2016], four of which we believe to be particularly important: dynamic document generation: [@ruleTenSimpleRules2019], version control [@barbaHardRoadReproducibility2016], dependency management [@askrenUsingMakeReproducible2016], and containerization [@clyburne-sherinComputationalReproducibilityContainers2018]. We argue that only a workflow using all four concepts in unison can guarantee confidence in reproducing a scientific report [see @turingway2020 for similar arguments]. Various implementations of these concepts exist, but we consider the following four best suited for analyses centered on the R environment [@r2019] but also allowing for external dependencies: R Markdown [@rmarkdown2019] for dynamic document generation, Git [@chaconProGit2014] for version control, Make [@feldmanMakeProgramMaintaining1979] for dependency management, and Docker [@merkelDockerLightweightLinux2014] for containerization. Each of these software solutions serves a valuable meta-scientific goal (reproducibility) and increases the researches' productivity. They all are highly flexible and powerful, so that mastering them fully, requires a considerable amount of practice. However, for our purposes, it is sufficient to master a valuable minimal subset of functions to ensure the reproducibility of scientific analyses. We recommend using RStudio, an integrated development environment (IDE) for R, which provides simplified access to essential features of some of the tools.

# The Reproducible Workflow in a Nutshell

```{r schematic, eval = TRUE, echo = FALSE, fig.cap="Schematic illustration of the interplay of the four components (in dashed boxes) central to the reproducible workflow: version control (git), dependency management (Make), containerization (Docker), and dynamic document generation (R Markdown). Git tracks changes to the project over time. Make manages dependencies among the files. Docker provides a container, in which the final report is built using dynamic document generation in R Markdown.  "}
knitr::include_graphics("Images/nutshell.svg", auto_pdf = TRUE)
```

Figure \@ref(fig:schematic) gives an overview of how the four components of our workflow interact to ensure computational reproducibility. Before we describe the four components in more detail, we begin with a minimal description of the roles of each component. In the remainder of this tutorial, we will further detail each of the four components of our workflow. The first component is version control. Version control manages changes to files (e.g., data and code) over time so that you can recall specific versions of files later or revert the entire project to a past state. Version control offers snapshots of your workflow at different time points identified by a unique identifier. The different frames in the z-axis of Figure  \@ref(fig:schematic) illustrate the different versions of the project. How different parts of a analysis and a report of it relate and in what order they need to be executed is documented using dependency management. The arrows visualize dependencies, such as an analysis depending on the availability of a particular data file. Third, all computer code (such as a statistical analyses in R) is executed in a virtual environment that guarantees exact reproduction of results independent of the host operating system, the locally installed R version, and installed package versions. Finally, dynamic document generation (also known as the literate programming paradigm) interweaves human-readable code and computed results (such as point estimates, p values, or confidence intervals) to eliminate inconsistency errors such as those arising from copy\&paste errors. 


# Dynamic Document Generation

The translation of computational results into a human-readable summary, for example into a technical report, a presentation, or a journal manuscript, is time-consuming and error-prone. Typical errors result from copy\&paste mistakes, erroneous rounding, or missed updates of the manuscript when the associated computer code and computed results have changed. In order to create not only fully reproducible results but also fully reproducible reports, we resort to the literate programming paradigm [@knuth1984literate], in which human-readable language and computer code are mixed to create dynamic documents whose order follows the logic of thought rather then the order of the computer. R Markdown is a simple markup language to create dynamic documents with embedded chunks of R code that can be exported to standard formats such as documents (docx, rtf, epub), presentations (ppt, html) or websites (html) using the `knitr` package [@xie2015; @xie2019]. Several packages extend the functionality of knitr. Of particular note are the `papaja` package [@papaja2018], which offers additional functions to enable American Psychological Association (APA) style document formatting, including a journal-style final typeset format, and the `stargazer` package [@stargazer2018], which provides journal-ready tables and reports of statistical models.  Figure \@ref(fig:source-rmarkdown) illustrates R Markdown syntax using the `papaja` package and Figure \@ref(fig:rendered-result) shows the resulting rendered document.

```{r source-rmarkdown, eval = TRUE, echo = FALSE,  fig.cap="Exemplary excerpt of an R Markdown file showing a combination of executable R code, which will be dynamically rendered to content on document creation, and English manuscript text. Code is either given in separate chunks (shown in grey background delimited by triple backticks) or inline (single backticks). The resulting document is shown in Figure \\ref{fig:rendered-result}. "}
knitr::include_graphics("Images/rmarkdown.png")
```

```{r rendered-result, eval = TRUE, echo = FALSE,  fig.cap="Rendered result of the source code shown in Figure \\ref{fig:source-rmarkdown}."}
knitr::include_graphics("R/rmarkdown.pdf")
```


# Version Control

Fundamentally, reproducibility means that computational results remain identical if neither the script nor the data have changed. It is often not trivial to find out whether any element in a project has changed over time and if so, to "go back in time." The Git program enables you to do both. A good mental model for Git is that it takes a sequence of snapshots of all files it is supposed to track. In the language of Git, these snapshots are "commits." A commit represents a complete copy of the state of all tracked files. Each commit has a short, unique identifier (a hash code) and a human-readable description (commit message). Going back to one state is as easy as traversing the history of all commits and switching the repository to a given previous state; it is possible to visually compare changes between different versions. The collection of all snapshots is called a "repository," which ideally tracks your entire R project.

A typical Git workflow in the terminal looks like this:

```{bash, eval=FALSE}
# -- type this in a terminal --
git init # to initialize Git in the current directory
git add ./data/iris.csv ./R/analysis.R # track specific files
git commit -m "added data and analysis" # take snapshot with comment
# once script or data were changed, take a new snapshot
git commit -a -m "completed data collection" # add and commit all changes
```

To keep track of all changes on your local computer, you only need to use `git add` and `git commit` or `git commit -a` to add and commit at the same time. Adding a file means to save its changes on the next commit. These commands need to be executed in the terminal, which you can access from within RStudio (`Shift + Alt + R`).  RStudio also offers a graphical user interface for Git. For most basic operations, this interface is convenient and sufficient (see Figure \@ref(fig:gitpane)).

```{r gitpane, eval = TRUE, echo = FALSE, fig.cap="Git Pane providing easy access to basic functions in RStudio"}
knitr::include_graphics("Images/git-pane.png")
```

In a given Git project, you can inspect all changes (`git log`) and examine any previous state by stating the identifier of the commit to `git checkout`:

```{bash, eval = FALSE}
# -- type this in a terminal --

# inspect all changes
git log
# revert local directory to previous version with hash '77db06f78e'
git checkout 77db06f78e 
```

Git also makes it particularly easy to share and collaborate on a project with other researchers. A popular service for sharing materials via Git is [GitHub](https://github.com). Alternatively, institutions can host an equally feature-rich open-source service called [GitLab](https://gitlab.com), avoiding the reliance on commercial service providers. At the time of writing, sharing repositories on GitHub with the public is free, private repositories (only visible to persons you invite) are [free for researchers](https://help.github.com/en/articles/applying-for-an-educator-or-researcher-discount) or have limited features. After creating a user account, one can create a new repository and GitHub provides information on how to upload your repository from the terminal, e.g., for our repository (here with user name 'aaronpeikert' and repository name 'reproducible-research'):

```{bash, eval=FALSE}
# -- type this in a terminal --

# link remote github repository to local directory
git remote add origin https://github.com/aaronpeikert/reproducible-research.git
# push all changes from local repository to the remote repository
git push -u origin master
```

`git push` or the green upward arrow in the Git pane (see Figure \@ref(fig:gitpane)) uploads local updates. To download the remote Git repository on another computer, type into the terminal:

```{bash, eval=FALSE}
# -- type this in a terminal --
git clone https://github.com/aaronpeikert/reproducible-research.git
```

Git and GitHub can do even more to support you when collaborating with fellow researchers, for example, by providing a web interface to track issues and their status (open/closed/resolved) and further means to manage and merge multiple, parallel versions of code (such as branches, pull requests, or merges), but this is beyond the scope of this tutorial. In particular, GitHub's issue management can be leveraged as a post-publication platform to discuss manuscripts and their results [^1].
Another benefit of using Git and GitHub is that experimentation is highly encouraged since you can go back to any state quickly. Even when you lose access to the file on your computer, everything can be backed up on a remote Git server (like GitHub or GitLab). Further, one can reduce the likelihood of dead code accumulating (e.g., lines that have been commented out) because it is safe to simply remove unneeded code blocks and track their removal in Git.

GitHub allows you to archive and label a specific version of your repository in the form of a release. A release tags a particular commit with an arbitrary label, e.g., as "submission,"[^sub] "preprint," or "published," and archives also "binary" products of your code, e.g. the resulting pdf of the manuscript or the docker image (see [Containerization]). From such a release [zenodo.org](https://zenodo.org) can create a DOI, making it easier to reference it (see this [GitHub Guide](https://guides.github.com/activities/citable-code/)[^doi]).

[^1]: To comment on our paper, please add an issue to the GitHub repository of our paper: [https://github.com/aaronpeikert/reproducible-research/issues](https://github.com/aaronpeikert/reproducible-research/issues).
[^doi]: [https://guides.github.com/activities/citable-code/](https://guides.github.com/activities/citable-code/)
[^sub]: We created an release for the submission: [https://github.com/aaronpeikert/reproducible-research/releases/tag/v0.2.1-submission](https://github.com/aaronpeikert/reproducible-research/releases/tag/v0.2.1-submission)

# Dependency Tracking and Management

Even when you have obtained a given version of a project with the aim to reproduce reported results, and you can confirm that this version is unchanged, you may not know exactly how to reproduce the results because it may be unclear which files should be executed in which order. This is particularly the case when complex preprocessing pipelines are part of the computation or there are dependencies on external programs. Handling such dependencies is easy with Make because it allows you to manage dependencies by creating (computational) recipes to create or recreate files.

A `Makefile` obeys a simple scheme. It contains a list of recipes. Each recipe has a target (the name of the recipe) followed by a colon and a list of dependent targets or files. This is comparable to a cooking recipe where you have the resulting dish at the top, the required ingredients after that and at last the steps one has to follow to prepare the dish. If any of the dependencies have changed since the last time the target was built, the recipe's commands are executed to recreate the target file. We illustrate the use of Makefiles with an example. Assume the final product is a manuscript (`manuscript.pdf`). This manuscript is written in Rmarkdown (`manuscript.Rmd`) and includes dynamically generated plots from a raw data file (`data/iris.csv`) that needs to be preprocessed first using a separate script (`R/prepare_data.R`) into a prepared data file (`iris_prepped.csv`). You find a graphical representation of this example in Figure \@ref(fig:schematic). A `Makefile` for these dependencies may look like this:

```{bash, eval=FALSE}
# -- this is a Makefile --
all: manuscript.pdf

manuscript.pdf: data/iris_prepped.csv manuscript.Rmd
  Rscript -e 'rmarkdown::render("manuscript.Rmd")'

data/iris_prepped.csv: R/prepare_data.R data/iris.csv
  Rscript -e 'source("R/prepare_data.R")'
```

The first line after the comment is the first (default) target called 'all', which depends on manuscript.pdf, which itself is a target. If Make is called without an argument, the first target is built. To create `manuscript.pdf` (the second target in the file), the file `manuscript.Rmd` needs to be rendered, which depends on `data/iris_prepped.csv`. This dependency is itself a target (the third target in the file). To create `data/iris_prepped.csv`, `R/prepare_data.R` and `data/iris.csv` are needed. If you type `make manuscript.pdf`, Make first checks whether the dependencies do exist and, if not, creates them. Here, if `data/iris_prepped.csv` does not exist, Make creates it by executing the third target. Also, if one of the dependencies of a target is newer than the target itself, Make updates everything that directly or indirectly depends on the target. Here, if `data/iris.csv` is newer than `data/iris_prepped.csv`, Make will attempt to recreate `data/iris_prepped.csv` first and then `manuscript.pdf`. If there is a dependency missing, and there is no target to make it, Make stops with an error message. This way Make ensures that all four dependencies of the manuscript (the raw data `data/iris.csv`, the data preparation script `R/prepare_data.R`, the prepared data `data/iris_prepped.csv` and the manuscript source file `manuscript.Rmd`) are correctly resolved. It is a convention to have the first target named `all`, which creates the entire project. Subsequently, the command `make` without any argument automatically creates everything possible in the project. The button `Build All` from within RStudio triggers this process (see Figure \@ref(fig:buildpane-rstudio)).

```{r buildpane-rstudio, eval=TRUE, echo=FALSE, fig.cap="Build pane in RStudio with access to Makefile target 'all'."}
knitr::include_graphics("Images/build-pane.png")
```


If you have followed our workflow as presented thus far, a fellow researcher is only three commands away from fully reproducing your analysis. They would simply have to type the following commands in the terminal:

```{bash, eval=FALSE}
# -- type this in a terminal --

# obtain a local copy from the remote repository
git clone https://github.com/aaronpeikert/reproducible-research.git
# enter the local copy
cd iris
# create all files from that project
make all
```

If you execute the above on your system, there is a good chance that you cannot reproduce our manuscript and the `make all` command results in an error. Successful reproducibility relies on the crucial assumption that your computational environments are identically or sufficiently compatible, e.g., all software dependencies are installed (R and all additional R Packages) and no updates or other changes to the computational environment break or alter your analysis. As we will shortly see, ensuring full computational reproducibility requires one further level of documentation, that is, documentation of the computational environment.

# Containerization

Docker is a tool that allows encapsulation, sharing, and re-creation of a computational environment on most operating systems (Windows, macOS, & Linux). Docker achieves these goals by setting up a virtual computer, on which it can execute commands (e.g., installing software). It then saves the resulting state of the virtual computer in what is called an "image." This image can be started and execute commands on the virtual computer, e.g., running `Rscript` or `make`. A running instance of an image is called a container. An image can be transferred and executed on any machine that has Docker installed. Regardless of the machine that is executing the container, the computational environment is identical for the programs running inside the container. The most important advantage over traditional virtual machines is that containers are lightweight: they start rapidly, run with little overhead, and do not need much storage space. Docker achieves this by reusing large parts of the host's operating system (the extent varies between Linux, macOS and Windows).

With the following example, we demonstrate the importance of documenting and storing the computational environment. Generally, with containers, we would like to safeguard against changes to the computational environment resulting in unexpected consequences, e.g., changes in the functionality or default options in packages or even in the R environment itself. While the R programming language is considered stable and much effort is put into backward compatibility, even basic functions like `read.csv()` (to load data) or `sample()` (to randomly sample from a set) sometimes change their behaviour from one version to another. For example, to ensure reproducibility of analyses based on a computer's pseudo random number generator (PRNG), it is good practice to rely on fixed PRNG seeds, which are numeric values that set the PRNG into a deterministic state, i.e., the sequence of random numbers reproduces exactly. Consider the following R code to randomly draw five numbers between 1 and 10:

```{r,eval=FALSE}
# -- R code --
set.seed(1234)
sample(1:10, 5)
```

The usual expectation is that this code delivers the same pseudo-random five numbers regardless of the operating system or R Version (because of `set.seed()`). Using Docker, we can start an image which contains the R Version 3.5.0, and execute the code there.

```{r random, eval=FALSE}
```

This outputs:

```{r, child="R/random35.md"}
```

When executing the code in an image with a more recent version of R (3.6.1), the function results in another sample despite the identical random seed:

```{r random, eval=FALSE}
```

This outputs:

```{r, child="R/random36.md"}
```

Note, that this is intended behaviour as it is the result of a [bugfix](https://bugs.r-project.org/bugzilla/show_bug.cgi?id=17494) in the random number generator implemented from R 3.6.0 upwards. Now, such changes may strictly render analyses run on previous R versions not reproducible if they contain, e.g., multiple imputations, bootstrapping, simulations studies, graphics with random jitter, Bayesian estimations using sampling algorithms (such as Markov Chain Monte Carlo), or similar techniques that involve random sampling. We would like to illustrate this with a more concrete example (the full R code to reproduce this non-reproducibility is provided in the GitHub repository of this manuscript). We ran a linear regression model on a simulated dataset with two variables `x` and `y` with R's `lm()` function regressing `x` on `y`. Using the `boot` package [@boot], we bootstrapped the 95% confidence intervals around the regression coefficient estimate with 1000 bootstrap samples to evaluate whether the estimated confidence interval included zero. To make the analysis reproducible, we set a random seed. We ran this once in R 3.5.0:

```{r bootstrap, echo=TRUE, eval=FALSE}
```

```{r, child="R/bootstrap35.md"}
```

Subsequently, we ran the identical script with the identical seed in R 3.6.1:

```{r bootstrap, echo=TRUE, eval=FALSE}
```

```{r, child="R/bootstrap36.md"}
```

As we see from these R outputs, the latter of the estimated confidence intervals does include zero while the former does not. Please note that one could discuss deeper issues about null hypothesis significance testing here, but with this example, we would simply like to stress that computational reproducibility in the strict sense requires capturing the full computational environment.

Only rarely does an analysis depend on base R only. Typically, a considerable number of packages is required that each may depend on multiple other packages. Each update of each package in this dependency hierarchy and updates to base R itself will increase the likelihood of breaking reproducibility (the resulting frustration is sometimes referred to as _dependency hell_). The whole endeavour of reproducibility is therefore at stake every time an update is rolled out. To ensure long-term reproducibility, our worflow replicates the original computational environment of an analysis exactly. Note, that we do not intend to advocate that software should not be updated; updates typically promote bugfixes and provide new functionality; our point is that full computational reproducibility is only achieved if the software versions used originally are precisely documented. Among other things, this makes it possible to trace back update histories to discover which change in which package caused the non-reproducibility. Quite to the contrary, with containerization, it gets easier than ever to safely update to new versions just by changing the R version number of the Docker image (and reverting back if this update breaks code). This convenience is possible because of the efforts of the [Rocker project](https://GitHub.com/rocker-org/rocker) [@boettigerIntroductionRockerDocker2017a], which provides Docker images pre-configured with an installation of selected R versions. These packages are taken from MRAN [@revolutionanalyticsReproducibilityUsingFixed2019], a repository for R packages fixed to the last date on which the R version of the image was the most recent. Building upon these Rocker images, researchers can easily build their own Docker images with all required R packages. The rocker project also provides images that include RStudio (`rocker/rstudio`), the `tidyverse` package (`rocker/tidyverse`) and the R Markdown package with LaTeX (`rocker/verse`). Because our workflow relies on R Markdown, we suggest using the `rocker/verse` image (which also contains `rstudio` & `tidyverse`). These images are stored on [Dockerhub](https://hub.docker.com) [@dockerinc.DockerHub2019].

Building on a basic Rocker image, we can specify further software dependencies in a Dockerfile. For example, the basis for this manuscript's Docker image is the following Dockerfile:

```{bash, eval=FALSE}
# -- this is a Dockerfile --

# Define the R version to be installed from rocker project
FROM rocker/verse:3.6.1
# install CRAN R packages: pacman, here, and pander
RUN install2.r --error --skipinstalled\
  pacman here pander
# install additional R packages from github: papaja and wordcountaddin
RUN installGithub.r\
  crsh/papaja benmarwick/wordcountaddin
# set the working directory inside the container
WORKDIR /home/rstudio
```

The `FROM` statement specifies which Docker image to use, in this case, the `rocker/verse` image with the tag 3.6.1 (referring to the R version 3.6.1). The `RUN` statement describes a command to execute, in this case, to run an R script `install2.r` which is available on all Rocker images, to install the specified packages (here, `pacman`,  `here` & `pander`). A Dockerfile allows more than one `RUN` statement, executing arbitrary system commands. Those `RUN` statements can install dependencies that are not an R package, e.g., other programming languages like python or Matlab. The `WORKDIR` statement is not strictly necessary but saves time spent on writing the working directory. The command `docker build -t image-name` creates an image named `image-name` from the Dockerfile in the project. A way to identify the dependencies automatically and generate a docker image out of them is provided in the [`liftR`](https://cran.r-project.org/web/packages/liftr/vignettes/liftr-intro.html) package [@liftr].

The flexibility to fully control the software environment is of particular interest for software infrastructures where users cannot install software because of limited access rights, for example, on cloud computing platforms or high-performance computing clusters. However, Docker needs unrestricted access rights to the system, which are rarely granted on high-performance computing clusters. For this case, Singularity provides a fully compatible alternative (see Section on Linux) that can be executed with limited access rights.

There are two ways to share a Docker image; either by sharing the Dockerfile that creates the image or by sharing the image itself, e.g., through a service like [Dockerhub](https://hub.docker.com). While both ways guarantee a replicable computational environment, sharing the Dockerfile is more transparent and more space-saving; in our workflow, we can use Git to track changes in the Dockerfile (such as updates to dependencies). A possible downside is that in order to create an image from a Dockerfile, all software repositories need to be still available. Hence, to guarantee longterm reproducibility, it is best to archive the complete binary image at major points of the projects' progress, for example, on publication (ideally, using a release tag; see Section _Version Control_ for details).

There are two options to execute commands in a container. Both options are based on the `docker run` command. The first way is to run a command inside the container. The call takes the form:

```{bash, eval=FALSE}
# -- type this in a terminal --

# execute a command in a container image; do not save the state 
# of the container; accept inputs from and return outputs to terminal
docker run --rm -it <IMAGENAME> <COMMAND>
```

The `--rm` flag means that the state of the container after the command will have finished is not going to be saved. The `-it` flag tells Docker to run the command interactively, that is, to accept keyboard inputs and return outputs to the terminal. For example, this is the command to start an interactive R session inside a Docker image called `reproducible-research` (see Figure \@ref(fig:docker-r-terminal) for a screenshot):

```{bash, eval=FALSE}
# -- type this in a terminal --

# start an interactive R session in the 
# container named 'reproducible-research'
docker run --rm -it reproducible-research R
```

```{r docker-r-terminal, eval = TRUE, echo = FALSE, fig.cap="R terminal running inside Docker"}
knitr::include_graphics("Images/docker-r-terminal.png")
```

The second option is to start the container in the background and to interact with the container via the web browser and the RStudio server instance running in it. In order to do so, you need to supply a password to log into the RStudio server (`-e PASSWORD=<YOUR_PASS>`) and open a local network service on a specified port (`-p 127.0.0.1:8787:8787`).

```{bash, eval=FALSE}
docker run -e PASSWORD=<YOUR_PASS> -p 127.0.0.1:8787:8787 image-name
```

The address to connect to the RStudio server is your IP address (or `localhost` on Linux) in this scheme: `<IPADDRESS>:8787`. This offers a fully functioning RStudio instance that runs in the image but is accessible through a local web browser.

```{r rstudio-in-docker, eval = TRUE, echo = FALSE, fig.cap="RStudio running inside Docker"}
knitr::include_graphics("Images/docker-rstudio.png")
```

Figure \@ref(fig:rstudio-in-docker) shows a screenshot of Rstudio running inside Docker accessed from a local web browser.

By default, programs inside the container cannot access files on the local computer, thus requiring an explicit link to a local folder to enable access (and on macOS and Windows this also has to be allowed in the settings) :

```{bash, eval=FALSE}
docker run -v /folder/on/your/computer:/folder/in/docker
```

The main directory for RStudio inside the container is `/home/rstudio`, so the complete call to start RStudio inside a Docker container may look like this in the local terminal:

```{bash, eval=FALSE}
# start docker in the background, open a local web service with a virtual
# Rstudio instance and enable access to selected local directories
docker run --rm -it -e PASSWORD=<YOUR_PASS> -p 8787:8787 -v
/path/to/project:/home/rstudio reproducible-research
```

Figure \@ref(fig:rstudio-in-docker) shows a screenshot of the result.

Since Docker commands tend to grow long and become tedious to type manually, we recommend using some automatic way to generate them. Fortunately, one can use Make to automatically generate the `docker` commands, e.g. the (simplified) `Makefile` for this paper allows the command after `$(run)` to be conditionally passed through Docker if one types `make DOCKER=TRUE` (otherwise, they are run locally):

```{bash, eval=FALSE}
# -- this is a Makefile --

# set local variables for later use
project := $(notdir $(CURDIR))
current_dir := $(CURDIR)
home_dir := $(current_dir)
uid = --user $(shell id -u)

# determine if DOCKER=TRUE was given
# if so, run everything in docker
# if not, run everything locally
ifeq ($(DOCKER),TRUE)
    run:=docker run --rm --user $(uid) -v $(home_dir):/home/rstudio $(project)
    current_dir=/home/rstudio
endif

# default target is target 'manuscript.pdf'
all: manuscript.pdf

# build the docker container
build: Dockerfile
    docker build -t $(project) .

# build manuscript.pdf from Rmd file
# run in docker if DOCKER=TRUE else locally
manuscript.pdf: manuscript.Rmd reproducible-research.bib
    $(run) Rscript -e 'rmarkdown::render("$(current_dir)/$<")'
```

# Installing and Setting Up the Workflow

Other than on R, RStudio, and R Markdown, our workflow relies on three pieces of software from outside the R environment: Git, Make, and Docker. The smoothness of the installation process of these software packages varies across operating systems. For example, on macOS, Make is always available, whereas Linux systems are typically shipped with both Git and Make. In the following section, we share what we consider the easiest way to install those packages across common operating systems. However, installation processes may be subject to change, and we advise that readers also consult the documentations of the packages or see our collection of links to tutorials and installation instructions on our GitHub repository.

## Windows

Windows systems typically require the biggest efforts to install all necessary pieces of software. Note, that you must have either Windows Pro, Enterprise, Education, or Server installed, as Microsoft prevents the use of Docker on Windows Home[^home]. There is a package manager for Windows called Chocolatey, which you can install from: [https://chocolatey.org/install](https://chocolatey.org/install). Chocolatey provides all software packages needed for our workflow in one place.
Having installed Chocolatey (and restarted the computer), all dependencies can be installed in an **admin terminal** (Windows key, then type `cmd`, right-click *Run as administrator*) via:

```{bash, eval=FALSE}
# -- type this in a terminal --

# install Docker, Make, and Git using Chocolatey
choco install -y git make docker-desktop
```

To use `docker` you need to start Docker Desktop. In the settings of Docker Desktop, you have to allow the sharing of your drive. Docker on Windows requires an unusual path specification (e.g., `C:\Users\aaron\Documents\reproducible-research` becomes `/c/Users/aaron/Documents/reproducible-research`). Therefore, you currently need to hand-edit the `Makefile` and set `current_path` to the project directory and use `make all DOCKER=TRUE WINDOWS=TRUE`. We hope that future releases of Docker for Windows will not require that workaround.

[^home]: See the section on [related approaches] for some alternatives to Docker in case you have to use Windows Home.

## macOS

As Make already ships with macOS, you only need Git and Docker. We suggest using the package manager Homebrew, which you can install from [https://docs.brew.sh/Installation](https://docs.brew.sh/Installation), to install Docker (Git will be installed during the installation of Homebrew):

```{bash, eval=FALSE}
# -- type this in a terminal --

# install Docker via Homebrew
brew cask install docker
```

To use `docker`, you need to start Docker Desktop. In the settings of Docker you have to allow the sharing of your drive.

## Linux

There is a host of different Linux distributions and almost as many package managers. Still, to our knowledge, there is no (recent) Linux edition, that does not include Git, Make and Docker. For example, in Ubuntu Linux, installation is straightforward using the shipped package manager:

```{bash, eval=FALSE}
# -- type this in a terminal --

# install Docker via advanced package tool
apt install git make docker
```

For other distributions, replace `apt install` with your package manager's equivalent. You may need elevated rights for the installation; in this case, add `sudo` before the installation command. `docker` also needs elevated rights to run; therefore, we recommend adding the local user to the `docker` group, following the [documentation of Docker](https://docs.docker.com/install/linux/linux-postinstall/#manage-docker-as-a-non-root-user).

An alternative to Docker on Linux is Singularity [@kurtzerSingularityScientificContainers2017]. To use it, just replace any docker calls with `singularity docker` because Singularity fully supports docker images. A possible advantage is that Singularity works well in high-performance computing environments and on old Linux versions, the downside is that Singularity is currently only available on Linux.

# Project organization

Finally, we conclude with some notes on project organization, which we think makes migrating projects to a reproducible workflow easier. The first step towards reproducibility is to create an R script or R Markdown file as the primary entry point for the analysis that runs on a local computer without error and performs the main statistical analyses. Next, one needs to make sure that all files relevant to the analysis can be moved to another computer. To this end, it is recommended that all files reside within a one folder (or enclosed subfolders within it) and all paths are relative to that folder because absolute paths are specific to a given computer. A robust solution to the problem of making sure that file access does not break across computing platforms are [RStudio projects](https://r4ds.had.co.nz/workflow-projects.html) and the `here` package [@here2017] to manage file access. The `here` package solves two common issues with relative paths. First, it takes care of the fact that path separator characters vary across operating systems (typically, slash or backslash). Second, it solves the issue that anchor points of relative paths may differ depending on context. For example, knitr interprets paths relative to the dynamic document, whereas R has a current working directory that may change over the course of an R session. The `here` package provides consistent paths relative to the project directory. The following three examples refer to local files ranging from absolute paths with system-specific path separators (bad) to relative paths using the `here` package:

```{r, eval=FALSE}
# -- R code --

# BAD because of path that is specific to the computer
iris <- read.csv("/home/aaron/reproducible-research/data/iris.csv")
# GOOD because it is a relative path but slash depends on OS
iris <- read.csv("data/iris.csv")
# BETTER because truly compatible across OS
iris <- read.csv(here("data", "iris.csv"))
```

The folder where all the files reside that you need for analysis (code and data), is referred to as a 'project' (or sometimes as a 'research compendium'). Working with projects is particularly convenient with RStudio. It is useful to organize a data analysis project in a way that strictly segregates (raw) data and code by placing them in directories called `data` and `R` [see Section 4 in @marwickPackagingDataAnalytical2018]; there are also tools that automatize the standardized creation of folder structures such as `workflowr` [@workflowr].

Sometimes external requirements make it impossible for the data to be stored and shared with the scripts. In most of the cases we have seen, these are either space constraints or privacy considerations. In these cases, unrestricted reproducibility is not guaranteed. If dividing data and scripts is unavoidable, we recommend validating all data files using checksums (also called a "hash", e.g., using the functions provided in package `digest` [@digest2019]) before analyzing them. A checksum is a short fixed-length fingerprint (often displayed in the hexadecimal system) of a file with the purpose of verifying the integrity of a digital object. Fingerprints are computed from digital objects such that they change with high probability if data is changed only a little. To use checksum validation, checksums for all data files must be created and stored at the time of the original analysis. At the time of reproduction, the current checksum must be compared with the stored checksum to ensure data integrity.

```{r}
# create a dummy data.frame with two columns
x <- data.frame(VAR1=c(1,2,3,4),VAR2=c(0,4,6,9) )
# compute checksum using md5
checksum <- digest::digest(x, "md5")
if (checksum != "5ba412f5a26f43842971dd74954fcdeb"){
  warning("Mismatch between original and current data file!")
}
```


## Use Case: Reproducing an Analysis

We provide a reproducible analysis as a working example via [GitHub](https://github.com/aaronpeikert/workflow-showcase). We encourage interested readers to try to reproduce this example as a practical exercise. The example shows a minimalistic analysis of the 'Considerations of Future Consequences (CFC) Scale'. The analysis demonstrates a complete implementation of our workflow including downloads of external data, comparison of their integrity using a checksum, and  a confirmatory factor analysis on the first few items using the R package `lavaan` [@lavaan2012]. Once all required tools are installed on a computer, the following four command-line commands are sufficient to reproduce our demo analysis:

```{bash, eval=FALSE}
# -- type this in a terminal --

# (1) obtain a local copy of the remote repository
git clone https://github.com/aaronpeikert/workflow-showcase.git
# (2) enter the directory containing the project
cd workflow-showcase
# (3) build the docker container
make build
# (4) run the analysis and produce the final PDF inside the container
make all DOCKER=TRUE
```

# Summary

The overarching goal of this paper was to provide a complete and easy-to-use workflow that allows confidence in the reproducibility of R-based data analyses. Analyses following our workflow can be reproduced with four commands (here shown for this manuscript):

```{bash, eval=FALSE}
# -- type this in a terminal --

# (1) obtain a local copy of the remote repository
git clone https://github.com/aaronpeikert/reproducible-research.git
# (2) enter the directory containing the project
cd reproducible-research
# (3) build the docker container
make build
# (4) run the analysis and produce the final PDF inside the container
make all DOCKER=TRUE
```

The workflow enables reproduction a scientific report exactly without regard to the local operating system, locally installed software, time, or interim changes to the project files. To that end, the proposed workflow relies on tools that have been the foundation of reliable software development for years or even decades. As a by-product, it makes transparent how statistical results depend on the software that created them and, by virtue of this transparency, facilitates later reuse by other researchers.

Each tool in the workflow reduces the chances of non-reproducibility. Dynamic reporting with R Markdown guarantees consistency between computational results and their reporting; Version control with Git ensures permanence and consistency across multiple versions of data and code; Dependency management with Make provides defined entry-points while mapping out dependencies between all components of a project; containerization with Docker guarantees full computational reproducibility. We believe that the proposed combination of tools does not restrict researchers but enables them to operate on a solid basis to deliver transparent and sustainable research.

## Related approaches

While our approach was designed to scale well with the complexity of a computationally intense project, we realize that this flexibility may not be straightforward to integrate into researchers' everyday workflow. There are various R packages that implement parts of our workflow and, thus, lower the threshold for adoption when the full flexibility provided by our workflow is not needed. The use of R Markdown within a project, tracked with Git can be simplified with the [`workflowR`](https://github.com/jdblischak/workflowr) package [@workflowr]. The [`drake`](https://github.com/ropensci/drake) package [@drake] is directly inspired by Make and takes an R centric approach, making it especially suited for projects only involving R, but can also handle external dependencies. The [liftR ](https://cran.r-project.org/web/packages/liftr/vignettes/liftr-intro.html) package [@liftr] and the [`holepunch`](https://karthik.github.io/holepunch/) package [@holepunch] automatize the use of Docker. The former is perfectly compatible with the described workflow, and we recommend it to users who are not comfortable with command-line use of Docker. `holepunch` uses [binder](https://mybinder.org) [@binder2018] to move the analysis to the cloud, so that no local installation of Docker is required. `holepunch` is well suited for simple analyses with low computational demands because binder's memory and computing time is limited. There are several alternatives to Docker that manage dependencies on R packages. [`renv`](https://rstudio.github.io/renv/articles/renv.html) [@renv] is a way to freeze package version via local copies of packages in the project, but it does not guarantee a given base R version or system dependencies. Similar approaches are taken by [`jetpack`](https://github.com/ankane/jetpack) [@jetpack], [`miniCRAN`](https://cran.r-project.org/web/packages/miniCRAN/vignettes/miniCRAN-introduction.html) [@miniCRAN] and [`checkpoint`](https://cran.r-project.org/web/packages/checkpoint/vignettes/checkpoint.html) [@checkpoint]. The package [`reprex`](https://github.com/tidyverse/reprex) [**repr**oducible **ex**ample, @reprex] is also worth noting, but its scope is limited. A particularly noteworthy approach is the [`worcs`](https://cran.r-project.org/web/packages/worcs) package [@worcs; @worcspaper], which is an R project template that creates a standardized file structure for code and data supporting version management with Git, package management with `renv` and dynamic document generation with R Markdown. We acknowledge that worcs is much easier to install and provides a one-click solution for the creation of reproducible projects. It achieves a high standard of reproducibility but does not guarantee full computational reproducibility and is limited to dependency management within the R environment.

Other than these tools, which ease the process of creating workflows like ours does, we have noticed an increased interest in changing the way research is published and used [@perkelToolkitDataTransparency2018], with the emergence of *life code* [@perkelPioneeringLivecodeArticle2019] and *continuous integration* [@beaulieu-jonesReproducibilityComputationalWorkflows2017; @yenniDevelopingModernData2018]. These techniques give us a glimpse of a paradigm shift from static to dynamic, interactive, and living publications that is yet to happen.

## Limitations

We are aware that implementing the proposed workflow is not straightforward, and the difficulty of its implementation may vary by platform. For example, the installation of all tools is already easier on POSIX-compatible platforms such as Unix, Linux, or macOS (but not Windows). However, once a reproducible workflow is established as a default, it can be used with minimal changes for every R project.

In our own experience, it is often not possible to convince all co-authors to switch to a different document processing environment, such as R Markdown. That is, we have experienced the case that after writing up the first draft in R Markdown, we eventually had to generate a Word file that, from then on, was used as static file serving as a basis for multiple iterations among the co-authors. Retaining reproducibility in such situations then requires tedious manual synchronization of files across formats. This annoyance may be reduced with the [`redoc` package](https://noamross.github.io/redoc/articles/mixed-workflows-with-redoc.html) [@redoc], which enables a bidirectional synchronization between Word and R Markdown. Conversions between R Markdown and Word retain all changes and even support Word's track-changes feature.

## Sharing reproducible workflows

How can one best share a reproducible workflow? We believe that, ideally, a non-commercial public service provider should be found that guarantees permanent and reliable hosting of our reproducible workflows, such as the Open Science Framework [@fosterOpenScienceFramework2017]. A provider mirroring and complementing the services offered by GitHub, Docker Hub, and MRAN would be desirable. Second, to ensure that other users are legally able to benefit from the shared materials, authors must choose an appropriate license format. Typically, there is no single license that works for code, data, and media (such as text or figures). We encourage authors to choose appropriate license forms that do not hinder others from freely downloading, using, and modifying the shared workflows and materials while, at the same time, ensuring recognition for the time and effort invested in creating the workflow in the first place. In our experience, the [Creative Commons license (CC-BY)](https://creativecommons.org/licenses/by/4.0/) is often appropriate for sharing texts, R Markdown files, generated figures, and other media, whereas scripts and any other computer code are often best shared under the [MIT license](https://opensource.org/licenses/MIT) (or similar). Both licenses assure maximal freedom for future users while requiring the attribution of the original authors in derivative work. These licenses are also in line with the recommendations by the Reproducible Research Standard [@stoddenEnhancingReproducibilityComputational2016; @stoddenEnablingReproducibleResearch2009]. A great resource to choose a license is [choosealicense.com](https://choosealicense.com), however, no resource, including our recommendation, replaces legal advice. To facilitate an inclusive environment, we recommend naming all contributors and including a [Code of Conduct](https://opensource.guide/code-of-conduct/) in your project.

## Outlook

The proposed workflow leverages various existing tools that are partly integrated into RStudio already. Parts of the proposed workflow have been integrated into stand-alone packages [such as `worcs`, @worcs; `workflowr`, @workflowr; or `holepunch` @holepunch], which we recommend to beginners; in particular, `worcs` is a step-by-step procedure with best practices for Open Science from preregistration to publication. Still those approaches do either not guarantee full computational reproducibility or rely on proprietary service providers. We hope that with increasing awareness of the challenges of computational reproducibility, the increased demand for unified and open solutions will lead to better integration of existing tools and services to allow reproducible workflows to become a standard in psychological research.

\newpage

# References

\begingroup
\setlength{\parindent}{-0.5in}
\setlength{\leftskip}{0.5in}

<div id="refs" custom-style="Bibliography"></div>
\endgroup
